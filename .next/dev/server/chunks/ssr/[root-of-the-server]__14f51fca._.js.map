{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/panil/krishiglobal/krishi/lib/api/auth.ts"],"sourcesContent":["/**\r\n * Authentication API Client\r\n */\r\n\r\nimport axios from 'axios';\r\n\r\n// Backend API base URL - Update this to match your backend port\r\n// Default: http://localhost:5000 (matches backend default port)\r\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000/api/v1';\r\n\r\ninterface LoginRequest {\r\n  email: string;\r\n  password: string;\r\n}\r\n\r\ninterface RegisterRequest {\r\n  email: string;\r\n  password: string;\r\n  username?: string;\r\n  firstName: string;\r\n  lastName?: string;\r\n  phone?: string;\r\n}\r\n\r\nexport interface ApiResponse<T = any> {\r\n  success: boolean;\r\n  data?: T;\r\n  message?: string;\r\n}\r\n\r\ninterface AuthResponse {\r\n  user: {\r\n    id: string;\r\n    email: string;\r\n    username?: string;\r\n    firstName: string;\r\n    lastName?: string;\r\n    role: string;\r\n    emailVerified: boolean;\r\n  };\r\n  tokens?: {\r\n    accessToken: string;\r\n    refreshToken: string;\r\n  };\r\n}\r\n\r\n// Register new user\r\nexport const register = async (data: RegisterRequest): Promise<ApiResponse<AuthResponse>> => {\r\n  try {\r\n    const response = await axios.post(`${API_BASE_URL}/auth/register`, data, {\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n    });\r\n    return response.data;\r\n  } catch (error: any) {\r\n    // Re-throw with better error information\r\n    if (error.response) {\r\n      // Server responded with error\r\n      const apiError = new Error(error.response.data?.message || 'Registration failed');\r\n      (apiError as any).response = error.response;\r\n      throw apiError;\r\n    } else if (error.request) {\r\n      // Request made but no response\r\n      throw new Error('Network error. Please check your connection.');\r\n    } else {\r\n      // Something else happened\r\n      throw error;\r\n    }\r\n  }\r\n};\r\n\r\n// Login user\r\nexport const login = async (data: LoginRequest): Promise<ApiResponse<AuthResponse>> => {\r\n  const response = await axios.post(`${API_BASE_URL}/auth/login`, data);\r\n  return response.data;\r\n};\r\n\r\n// Logout user\r\nexport const logout = async (): Promise<void> => {\r\n  try {\r\n    const token = typeof window !== 'undefined' ? localStorage.getItem('accessToken') : null;\r\n    await axios.post(`${API_BASE_URL}/auth/logout`, {}, {\r\n      headers: {\r\n        Authorization: `Bearer ${token}`\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Logout error:', error);\r\n  } finally {\r\n    // Clear tokens regardless of API call success\r\n    localStorage.removeItem('accessToken');\r\n    localStorage.removeItem('refreshToken');\r\n  }\r\n};\r\n\r\n// Get current user profile\r\nexport const getProfile = async (): Promise<ApiResponse<any>> => {\r\n  const token = typeof window !== 'undefined' ? localStorage.getItem('accessToken') : null;\r\n  const response = await axios.get(`${API_BASE_URL}/auth/me`, {\r\n    headers: {\r\n      Authorization: `Bearer ${token}`\r\n    }\r\n  });\r\n  return response.data;\r\n};\r\n\r\n\r\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;AAED;;AAEA,gEAAgE;AAChE,gEAAgE;AAChE,MAAM,eAAe,oEAAmC;AAuCjD,MAAM,WAAW,OAAO;IAC7B,IAAI;QACF,MAAM,WAAW,MAAM,gJAAK,CAAC,IAAI,CAAC,GAAG,aAAa,cAAc,CAAC,EAAE,MAAM;YACvE,SAAS;gBACP,gBAAgB;YAClB;QACF;QACA,OAAO,SAAS,IAAI;IACtB,EAAE,OAAO,OAAY;QACnB,yCAAyC;QACzC,IAAI,MAAM,QAAQ,EAAE;YAClB,8BAA8B;YAC9B,MAAM,WAAW,IAAI,MAAM,MAAM,QAAQ,CAAC,IAAI,EAAE,WAAW;YAC1D,SAAiB,QAAQ,GAAG,MAAM,QAAQ;YAC3C,MAAM;QACR,OAAO,IAAI,MAAM,OAAO,EAAE;YACxB,+BAA+B;YAC/B,MAAM,IAAI,MAAM;QAClB,OAAO;YACL,0BAA0B;YAC1B,MAAM;QACR;IACF;AACF;AAGO,MAAM,QAAQ,OAAO;IAC1B,MAAM,WAAW,MAAM,gJAAK,CAAC,IAAI,CAAC,GAAG,aAAa,WAAW,CAAC,EAAE;IAChE,OAAO,SAAS,IAAI;AACtB;AAGO,MAAM,SAAS;IACpB,IAAI;QACF,MAAM,QAAQ,sCAAgC,0BAAsC;QACpF,MAAM,gJAAK,CAAC,IAAI,CAAC,GAAG,aAAa,YAAY,CAAC,EAAE,CAAC,GAAG;YAClD,SAAS;gBACP,eAAe,CAAC,OAAO,EAAE,OAAO;YAClC;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iBAAiB;IACjC,SAAU;QACR,8CAA8C;QAC9C,aAAa,UAAU,CAAC;QACxB,aAAa,UAAU,CAAC;IAC1B;AACF;AAGO,MAAM,aAAa;IACxB,MAAM,QAAQ,sCAAgC,0BAAsC;IACpF,MAAM,WAAW,MAAM,gJAAK,CAAC,GAAG,CAAC,GAAG,aAAa,QAAQ,CAAC,EAAE;QAC1D,SAAS;YACP,eAAe,CAAC,OAAO,EAAE,OAAO;QAClC;IACF;IACA,OAAO,SAAS,IAAI;AACtB"}},
    {"offset": {"line": 186, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/panil/krishiglobal/krishi/contexts/AuthContext.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { createContext, useContext, useState, useEffect, ReactNode } from 'react';\r\nimport { useRouter } from 'next/navigation';\r\nimport { login as loginApi, register as registerApi, logout as logoutApi, getProfile } from '@/lib/api/auth';\r\n\r\ninterface User {\r\n  id: string;\r\n  email: string;\r\n  username?: string;\r\n  firstName: string;\r\n  lastName?: string;\r\n  role: string;\r\n  emailVerified: boolean;\r\n}\r\n\r\ninterface AuthContextType {\r\n  user: User | null;\r\n  loading: boolean;\r\n  isAuthenticated: boolean;\r\n  login: (email: string, password: string) => Promise<void>;\r\n  register: (data: RegisterData) => Promise<void>;\r\n  logout: () => Promise<void>;\r\n  refreshUser: () => Promise<void>;\r\n}\r\n\r\ninterface RegisterData {\r\n  email: string;\r\n  password: string;\r\n  username?: string;\r\n  firstName: string;\r\n  lastName?: string;\r\n  phone?: string;\r\n}\r\n\r\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\r\n\r\nexport function AuthProvider({ children }: { children: ReactNode }) {\r\n  const [user, setUser] = useState<User | null>(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const router = useRouter();\r\n\r\n  // Check if user is authenticated on mount\r\n  useEffect(() => {\r\n    const checkAuth = async () => {\r\n      const token = localStorage.getItem('accessToken');\r\n      if (token) {\r\n        try {\r\n          const response = await getProfile();\r\n          if (response.success && response.data) {\r\n            setUser(response.data);\r\n          }\r\n        } catch (error) {\r\n          console.error('Auth check failed:', error);\r\n          localStorage.removeItem('accessToken');\r\n          localStorage.removeItem('refreshToken');\r\n        }\r\n      }\r\n      setLoading(false);\r\n    };\r\n\r\n    checkAuth();\r\n  }, []);\r\n\r\n  const login = async (email: string, password: string) => {\r\n    try {\r\n      const response = await loginApi({ email, password });\r\n      if (response.success && response.data) {\r\n        setUser(response.data.user);\r\n        // Store tokens if provided\r\n        if (response.data.tokens) {\r\n          localStorage.setItem('accessToken', response.data.tokens.accessToken);\r\n          localStorage.setItem('refreshToken', response.data.tokens.refreshToken);\r\n        }\r\n        router.push('/');\r\n      }\r\n    } catch (error: any) {\r\n      throw new Error(error.message || 'Login failed');\r\n    }\r\n  };\r\n\r\n  const register = async (data: RegisterData) => {\r\n    try {\r\n      const response = await registerApi(data);\r\n      if (response.success && response.data) {\r\n        setUser(response.data.user);\r\n        // Store tokens if provided\r\n        if (response.data.tokens) {\r\n          localStorage.setItem('accessToken', response.data.tokens.accessToken);\r\n          localStorage.setItem('refreshToken', response.data.tokens.refreshToken);\r\n        }\r\n        router.push('/');\r\n      }\r\n    } catch (error: any) {\r\n      throw new Error(error.message || 'Registration failed');\r\n    }\r\n  };\r\n\r\n  const logout = async () => {\r\n    try {\r\n      await logoutApi();\r\n    } catch (error) {\r\n      console.error('Logout error:', error);\r\n    } finally {\r\n      setUser(null);\r\n      localStorage.removeItem('accessToken');\r\n      localStorage.removeItem('refreshToken');\r\n      router.push('/');\r\n    }\r\n  };\r\n\r\n  const refreshUser = async () => {\r\n    try {\r\n      const response = await getProfile();\r\n      if (response.success && response.data) {\r\n        setUser(response.data);\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to refresh user:', error);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <AuthContext.Provider\r\n      value={{\r\n        user,\r\n        loading,\r\n        isAuthenticated: !!user,\r\n        login,\r\n        register,\r\n        logout,\r\n        refreshUser,\r\n      }}\r\n    >\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n}\r\n\r\nexport function useAuth() {\r\n  const context = useContext(AuthContext);\r\n  if (context === undefined) {\r\n    throw new Error('useAuth must be used within an AuthProvider');\r\n  }\r\n  return context;\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;AAJA;;;;;AAmCA,MAAM,4BAAc,IAAA,sNAAa,EAA8B;AAExD,SAAS,aAAa,EAAE,QAAQ,EAA2B;IAChE,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,iNAAQ,EAAc;IAC9C,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,iNAAQ,EAAC;IACvC,MAAM,SAAS,IAAA,+IAAS;IAExB,0CAA0C;IAC1C,IAAA,kNAAS,EAAC;QACR,MAAM,YAAY;YAChB,MAAM,QAAQ,aAAa,OAAO,CAAC;YACnC,IAAI,OAAO;gBACT,IAAI;oBACF,MAAM,WAAW,MAAM,IAAA,gIAAU;oBACjC,IAAI,SAAS,OAAO,IAAI,SAAS,IAAI,EAAE;wBACrC,QAAQ,SAAS,IAAI;oBACvB;gBACF,EAAE,OAAO,OAAO;oBACd,QAAQ,KAAK,CAAC,sBAAsB;oBACpC,aAAa,UAAU,CAAC;oBACxB,aAAa,UAAU,CAAC;gBAC1B;YACF;YACA,WAAW;QACb;QAEA;IACF,GAAG,EAAE;IAEL,MAAM,QAAQ,OAAO,OAAe;QAClC,IAAI;YACF,MAAM,WAAW,MAAM,IAAA,2HAAQ,EAAC;gBAAE;gBAAO;YAAS;YAClD,IAAI,SAAS,OAAO,IAAI,SAAS,IAAI,EAAE;gBACrC,QAAQ,SAAS,IAAI,CAAC,IAAI;gBAC1B,2BAA2B;gBAC3B,IAAI,SAAS,IAAI,CAAC,MAAM,EAAE;oBACxB,aAAa,OAAO,CAAC,eAAe,SAAS,IAAI,CAAC,MAAM,CAAC,WAAW;oBACpE,aAAa,OAAO,CAAC,gBAAgB,SAAS,IAAI,CAAC,MAAM,CAAC,YAAY;gBACxE;gBACA,OAAO,IAAI,CAAC;YACd;QACF,EAAE,OAAO,OAAY;YACnB,MAAM,IAAI,MAAM,MAAM,OAAO,IAAI;QACnC;IACF;IAEA,MAAM,WAAW,OAAO;QACtB,IAAI;YACF,MAAM,WAAW,MAAM,IAAA,8HAAW,EAAC;YACnC,IAAI,SAAS,OAAO,IAAI,SAAS,IAAI,EAAE;gBACrC,QAAQ,SAAS,IAAI,CAAC,IAAI;gBAC1B,2BAA2B;gBAC3B,IAAI,SAAS,IAAI,CAAC,MAAM,EAAE;oBACxB,aAAa,OAAO,CAAC,eAAe,SAAS,IAAI,CAAC,MAAM,CAAC,WAAW;oBACpE,aAAa,OAAO,CAAC,gBAAgB,SAAS,IAAI,CAAC,MAAM,CAAC,YAAY;gBACxE;gBACA,OAAO,IAAI,CAAC;YACd;QACF,EAAE,OAAO,OAAY;YACnB,MAAM,IAAI,MAAM,MAAM,OAAO,IAAI;QACnC;IACF;IAEA,MAAM,SAAS;QACb,IAAI;YACF,MAAM,IAAA,4HAAS;QACjB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,iBAAiB;QACjC,SAAU;YACR,QAAQ;YACR,aAAa,UAAU,CAAC;YACxB,aAAa,UAAU,CAAC;YACxB,OAAO,IAAI,CAAC;QACd;IACF;IAEA,MAAM,cAAc;QAClB,IAAI;YACF,MAAM,WAAW,MAAM,IAAA,gIAAU;YACjC,IAAI,SAAS,OAAO,IAAI,SAAS,IAAI,EAAE;gBACrC,QAAQ,SAAS,IAAI;YACvB;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,2BAA2B;QAC3C;IACF;IAEA,qBACE,8OAAC,YAAY,QAAQ;QACnB,OAAO;YACL;YACA;YACA,iBAAiB,CAAC,CAAC;YACnB;YACA;YACA;YACA;QACF;kBAEC;;;;;;AAGP;AAEO,SAAS;IACd,MAAM,UAAU,IAAA,mNAAU,EAAC;IAC3B,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT"}},
    {"offset": {"line": 311, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/panil/krishiglobal/krishi/lib/api/cart.ts"],"sourcesContent":["/**\r\n * Cart API Client\r\n */\r\n\r\nimport axios from 'axios';\r\n\r\n// Backend API base URL - Update this to match your backend port\r\n// Default: http://localhost:5000 (matches backend default port)\r\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000/api/v1';\r\n\r\nconst getAuthHeaders = () => {\r\n  const token = typeof window !== 'undefined' ? localStorage.getItem('accessToken') : null;\r\n  return {\r\n    Authorization: token ? `Bearer ${token}` : '',\r\n  };\r\n};\r\n\r\nexport interface ApiResponse<T = any> {\r\n  success: boolean;\r\n  data?: T;\r\n  message?: string;\r\n}\r\n\r\n// Get cart\r\nexport const getCart = async () => {\r\n  const response = await axios.get(`${API_BASE_URL}/cart`, {\r\n    headers: getAuthHeaders(),\r\n  });\r\n  return response.data;\r\n};\r\n\r\n// Add to cart\r\nexport const addToCart = async (\r\n  productId: string, \r\n  variantId: string | null, \r\n  quantity: number = 1,\r\n  variantName?: string\r\n) => {\r\n  const response = await axios.post(`${API_BASE_URL}/cart/items`,\r\n    { productId, variantId, variantName, quantity },\r\n    { headers: getAuthHeaders() }\r\n  );\r\n  return response.data;\r\n};\r\n\r\n// Update cart item\r\nexport const updateCartItem = async (productId: string, quantity: number, variantId?: string) => {\r\n  const response = await axios.put(`${API_BASE_URL}/cart/items/${productId}`,\r\n    { quantity, variantId },\r\n    { headers: getAuthHeaders() }\r\n  );\r\n  return response.data;\r\n};\r\n\r\n// Remove from cart\r\nexport const removeFromCart = async (productId: string, variantId?: string) => {\r\n  const params = variantId ? `?variantId=${variantId}` : '';\r\n  const response = await axios.delete(`${API_BASE_URL}/cart/items/${productId}${params}`, {\r\n    headers: getAuthHeaders(),\r\n  });\r\n  return response.data;\r\n};\r\n\r\n// Clear cart\r\nexport const clearCart = async () => {\r\n  const response = await axios.delete(`${API_BASE_URL}/cart`, {\r\n    headers: getAuthHeaders(),\r\n  });\r\n  return response.data;\r\n};\r\n\r\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;;;AAED;;AAEA,gEAAgE;AAChE,gEAAgE;AAChE,MAAM,eAAe,oEAAmC;AAExD,MAAM,iBAAiB;IACrB,MAAM,QAAQ,sCAAgC,0BAAsC;IACpF,OAAO;QACL,eAAe,sCAAQ,0BAAoB;IAC7C;AACF;AASO,MAAM,UAAU;IACrB,MAAM,WAAW,MAAM,gJAAK,CAAC,GAAG,CAAC,GAAG,aAAa,KAAK,CAAC,EAAE;QACvD,SAAS;IACX;IACA,OAAO,SAAS,IAAI;AACtB;AAGO,MAAM,YAAY,OACvB,WACA,WACA,WAAmB,CAAC,EACpB;IAEA,MAAM,WAAW,MAAM,gJAAK,CAAC,IAAI,CAAC,GAAG,aAAa,WAAW,CAAC,EAC5D;QAAE;QAAW;QAAW;QAAa;IAAS,GAC9C;QAAE,SAAS;IAAiB;IAE9B,OAAO,SAAS,IAAI;AACtB;AAGO,MAAM,iBAAiB,OAAO,WAAmB,UAAkB;IACxE,MAAM,WAAW,MAAM,gJAAK,CAAC,GAAG,CAAC,GAAG,aAAa,YAAY,EAAE,WAAW,EACxE;QAAE;QAAU;IAAU,GACtB;QAAE,SAAS;IAAiB;IAE9B,OAAO,SAAS,IAAI;AACtB;AAGO,MAAM,iBAAiB,OAAO,WAAmB;IACtD,MAAM,SAAS,YAAY,CAAC,WAAW,EAAE,WAAW,GAAG;IACvD,MAAM,WAAW,MAAM,gJAAK,CAAC,MAAM,CAAC,GAAG,aAAa,YAAY,EAAE,YAAY,QAAQ,EAAE;QACtF,SAAS;IACX;IACA,OAAO,SAAS,IAAI;AACtB;AAGO,MAAM,YAAY;IACvB,MAAM,WAAW,MAAM,gJAAK,CAAC,MAAM,CAAC,GAAG,aAAa,KAAK,CAAC,EAAE;QAC1D,SAAS;IACX;IACA,OAAO,SAAS,IAAI;AACtB"}},
    {"offset": {"line": 379, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/panil/krishiglobal/krishi/contexts/CartContext.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { createContext, useContext, useState, useEffect, useRef, ReactNode } from 'react';\r\nimport { useAuth } from './AuthContext';\r\nimport { getCart, addToCart as addToCartApi, updateCartItem, removeFromCart as removeFromCartApi, clearCart as clearCartApi } from '@/lib/api/cart';\r\n\r\nexport interface CartItem {\r\n  productId: string;\r\n  name: string;\r\n  brand: string;\r\n  image: string;\r\n  variant: string;\r\n  quantity: string;\r\n  price: number;\r\n  originalPrice: number;\r\n  count: number;\r\n}\r\n\r\ninterface CartContextType {\r\n  items: CartItem[];\r\n  loading: boolean;\r\n  addToCart: (item: Omit<CartItem, 'count'>) => Promise<void>;\r\n  removeFromCart: (productId: string, variant: string) => Promise<void>;\r\n  updateQuantity: (productId: string, variant: string, count: number) => Promise<void>;\r\n  clearCart: () => Promise<void>;\r\n  getTotalItems: () => number;\r\n  getTotalPrice: () => number;\r\n  syncCart: () => Promise<void>;\r\n}\r\n\r\nconst CartContext = createContext<CartContextType | undefined>(undefined);\r\n\r\nexport function CartProvider({ children }: { children: ReactNode }) {\r\n  const [items, setItems] = useState<CartItem[]>([]);\r\n  const [isLoaded, setIsLoaded] = useState(false);\r\n  const [loading, setLoading] = useState(false);\r\n  const { isAuthenticated, loading: authLoading } = useAuth();\r\n  const hasSyncedRef = useRef(false); // Prevent multiple syncs on login\r\n\r\n  // Helper function to check if a string is a valid MongoDB ObjectId\r\n  const isValidObjectId = (id: string): boolean => {\r\n    return /^[0-9a-fA-F]{24}$/.test(id);\r\n  };\r\n\r\n  // Load cart from localStorage (for both guest and authenticated users as backup)\r\n  const loadCartFromLocalStorage = (): CartItem[] => {\r\n    if (typeof window === 'undefined') return [];\r\n    try {\r\n      const savedCart = localStorage.getItem('cart');\r\n      if (savedCart) {\r\n        return JSON.parse(savedCart);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading cart from localStorage:', error);\r\n    }\r\n    return [];\r\n  };\r\n\r\n  // Save cart to localStorage (always save as backup)\r\n  const saveCartToLocalStorage = (cartItems: CartItem[]) => {\r\n    if (typeof window === 'undefined') return;\r\n    try {\r\n      localStorage.setItem('cart', JSON.stringify(cartItems));\r\n    } catch (error) {\r\n      console.error('Error saving cart to localStorage:', error);\r\n    }\r\n  };\r\n\r\n  // Load cart on mount and when auth state changes\r\n  useEffect(() => {\r\n    const loadCart = async () => {\r\n      if (typeof window === 'undefined') return;\r\n      \r\n      // Wait for auth to finish loading\r\n      if (authLoading) return;\r\n\r\n      try {\r\n        // Always load from localStorage first (as backup)\r\n        const localCart = loadCartFromLocalStorage();\r\n\r\n        // If authenticated, load from backend and merge with localStorage\r\n        if (isAuthenticated) {\r\n          setLoading(true);\r\n          try {\r\n            const response = await getCart();\r\n            if (response.success && response.data?.items && response.data.items.length > 0) {\r\n              // Convert backend cart items to frontend format\r\n              const backendCartItems: CartItem[] = response.data.items\r\n                .filter((item: any) => item.product) // Filter out items with deleted products\r\n                .map((item: any) => {\r\n                  const product = item.product;\r\n                  const productId = product?._id?.toString() || product?.toString() || '';\r\n                  \r\n                  // Find variant name if variantId exists\r\n                  let variantName = '';\r\n                  if (item.variantId && product?.variants) {\r\n                    const variant = product.variants.find((v: any) => \r\n                      v._id?.toString() === item.variantId || v._id === item.variantId\r\n                    );\r\n                    variantName = variant?.name || '';\r\n                  }\r\n\r\n                  return {\r\n                    productId,\r\n                    name: product?.name || '',\r\n                    brand: product?.brand?.name || '',\r\n                    image: product?.images?.[0] || '',\r\n                    variant: variantName,\r\n                    quantity: item.quantity?.toString() || '1',\r\n                    price: Number(item.unitPrice) || 0,\r\n                    originalPrice: Number(item.unitPrice) || 0,\r\n                    count: item.quantity || 1,\r\n                  };\r\n                })\r\n                .filter((item: CartItem) => item.productId); // Filter out invalid items\r\n\r\n              // Merge backend cart with localStorage cart (backend takes priority)\r\n              // Keep localStorage items that aren't in backend (for mock data)\r\n              const mergedCart = [...backendCartItems];\r\n              localCart.forEach((localItem: CartItem) => {\r\n                const existsInBackend = backendCartItems.some(\r\n                  (backendItem: CartItem) => \r\n                    backendItem.productId === localItem.productId && \r\n                    backendItem.variant === localItem.variant\r\n                );\r\n                // Only add local items if they're not in backend (mock data support)\r\n                if (!existsInBackend) {\r\n                  mergedCart.push(localItem);\r\n                }\r\n              });\r\n\r\n              setItems(mergedCart);\r\n              saveCartToLocalStorage(mergedCart);\r\n            } else {\r\n              // Backend cart is empty, use localStorage cart if available\r\n              if (localCart.length > 0) {\r\n                setItems(localCart);\r\n                saveCartToLocalStorage(localCart); // Ensure it's saved\r\n              } else {\r\n                setItems([]);\r\n                saveCartToLocalStorage([]); // Clear localStorage if both are empty\r\n              }\r\n            }\r\n          } catch (error) {\r\n            console.error('Error loading cart from backend:', error);\r\n            // Fallback to localStorage if backend fails\r\n            if (localCart.length > 0) {\r\n              setItems(localCart);\r\n              saveCartToLocalStorage(localCart); // Ensure it's saved\r\n            } else {\r\n              setItems([]);\r\n            }\r\n          }\r\n          setLoading(false);\r\n        } else {\r\n          // Guest user - load from localStorage only\r\n          if (localCart.length > 0) {\r\n            setItems(localCart);\r\n            saveCartToLocalStorage(localCart); // Ensure it's saved\r\n          } else {\r\n            setItems([]);\r\n          }\r\n        }\r\n        setIsLoaded(true);\r\n      } catch (error) {\r\n        console.error('Error loading cart:', error);\r\n        // Final fallback to localStorage\r\n        const localCart = loadCartFromLocalStorage();\r\n        setItems(localCart);\r\n        setIsLoaded(true);\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    loadCart();\r\n  }, [isAuthenticated, authLoading]);\r\n\r\n  // Save cart to localStorage whenever it changes (for both guest and authenticated users as backup)\r\n  useEffect(() => {\r\n    if (isLoaded && typeof window !== 'undefined') {\r\n      saveCartToLocalStorage(items);\r\n    }\r\n  }, [items, isLoaded]);\r\n\r\n  // Sync cart to backend when user logs in (only once)\r\n  useEffect(() => {\r\n    if (isAuthenticated && isLoaded && items.length > 0 && !authLoading && !hasSyncedRef.current) {\r\n      // Only sync if we have items and user just logged in (prevent multiple syncs)\r\n      hasSyncedRef.current = true;\r\n      const syncOnce = async () => {\r\n        await syncCartToBackend();\r\n      };\r\n      syncOnce();\r\n    }\r\n    \r\n    // Reset sync flag when user logs out\r\n    if (!isAuthenticated) {\r\n      hasSyncedRef.current = false;\r\n    }\r\n  }, [isAuthenticated, isLoaded, items.length, authLoading]);\r\n\r\n  const syncCartToBackend = async () => {\r\n    if (!isAuthenticated) return;\r\n\r\n    try {\r\n      // Sync each item to backend (only if productId is a valid ObjectId)\r\n      for (const item of items) {\r\n        // Skip items with invalid ObjectIds (mock data)\r\n        if (!isValidObjectId(item.productId)) {\r\n          console.warn(`Skipping sync for product ${item.productId} - not a valid MongoDB ObjectId`);\r\n          continue;\r\n        }\r\n        try {\r\n          await addToCartApi(item.productId, null, item.count, item.variant || undefined);\r\n        } catch (error) {\r\n          console.error('Error syncing cart item:', error);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error syncing cart:', error);\r\n    }\r\n  };\r\n\r\n  const syncCart = async () => {\r\n    if (!isAuthenticated) return;\r\n\r\n    try {\r\n      setLoading(true);\r\n      const response = await getCart();\r\n      if (response.success && response.data?.items && response.data.items.length > 0) {\r\n        const cartItems: CartItem[] = response.data.items\r\n          .filter((item: any) => item.product) // Filter out items with deleted products\r\n          .map((item: any) => {\r\n            const product = item.product;\r\n            const productId = product?._id?.toString() || product?.toString() || '';\r\n            \r\n            // Find variant name if variantId exists\r\n            let variantName = '';\r\n            if (item.variantId && product?.variants) {\r\n              const variant = product.variants.find((v: any) => \r\n                v._id?.toString() === item.variantId || v._id === item.variantId\r\n              );\r\n              variantName = variant?.name || '';\r\n            }\r\n\r\n            return {\r\n              productId,\r\n              name: product?.name || '',\r\n              brand: product?.brand?.name || '',\r\n              image: product?.images?.[0] || '',\r\n              variant: variantName,\r\n              quantity: item.quantity?.toString() || '1',\r\n              price: Number(item.unitPrice) || 0,\r\n              originalPrice: Number(item.unitPrice) || 0,\r\n              count: item.quantity || 1,\r\n            };\r\n          })\r\n          .filter((item: CartItem) => item.productId); // Filter out invalid items\r\n        \r\n        setItems(cartItems);\r\n        saveCartToLocalStorage(cartItems); // Save to localStorage as backup\r\n      } else {\r\n        // Backend cart is empty, try localStorage\r\n        const localCart = loadCartFromLocalStorage();\r\n        if (localCart.length > 0) {\r\n          setItems(localCart);\r\n        } else {\r\n          setItems([]);\r\n        }\r\n      }\r\n      setLoading(false);\r\n    } catch (error) {\r\n      console.error('Error syncing cart:', error);\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const addToCart = async (item: Omit<CartItem, 'count'>) => {\r\n    // If authenticated and productId is valid, add to backend first\r\n    if (isAuthenticated && isValidObjectId(item.productId)) {\r\n      try {\r\n        setLoading(true);\r\n        // Add to backend first\r\n        await addToCartApi(item.productId, null, 1, item.variant || undefined);\r\n        \r\n        // After successful backend add, reload cart from backend to ensure sync\r\n        const response = await getCart();\r\n        if (response.success && response.data?.items) {\r\n          const backendCartItems: CartItem[] = response.data.items\r\n            .filter((item: any) => item.product)\r\n            .map((item: any) => {\r\n              const product = item.product;\r\n              const productId = product?._id?.toString() || product?.toString() || '';\r\n              \r\n              let variantName = '';\r\n              if (item.variantId && product?.variants) {\r\n                const variant = product.variants.find((v: any) => \r\n                  v._id?.toString() === item.variantId || v._id === item.variantId\r\n                );\r\n                variantName = variant?.name || '';\r\n              }\r\n\r\n              return {\r\n                productId,\r\n                name: product?.name || '',\r\n                brand: product?.brand?.name || '',\r\n                image: product?.images?.[0] || '',\r\n                variant: variantName,\r\n                quantity: item.quantity?.toString() || '1',\r\n                price: Number(item.unitPrice) || 0,\r\n                originalPrice: Number(item.unitPrice) || 0,\r\n                count: item.quantity || 1,\r\n              };\r\n            })\r\n            .filter((item: CartItem) => item.productId);\r\n\r\n          setItems(backendCartItems);\r\n          saveCartToLocalStorage(backendCartItems);\r\n        }\r\n        setLoading(false);\r\n      } catch (error: any) {\r\n        console.error('Error adding to cart:', error);\r\n        setLoading(false);\r\n        // Show error to user\r\n        const errorMessage = error?.response?.data?.message || error?.message || 'Failed to add item to cart';\r\n        alert(errorMessage);\r\n        throw error; // Re-throw so calling code can handle it\r\n      }\r\n    } else {\r\n      // For guest users or mock data, update local state and localStorage\r\n      setItems((prevItems) => {\r\n        const existingItem = prevItems.find(\r\n          (i) => i.productId === item.productId && i.variant === item.variant\r\n        );\r\n\r\n        let updatedItems: CartItem[];\r\n        if (existingItem) {\r\n          updatedItems = prevItems.map((i) =>\r\n            i.productId === item.productId && i.variant === item.variant\r\n              ? { ...i, count: i.count + 1 }\r\n              : i\r\n          );\r\n        } else {\r\n          updatedItems = [...prevItems, { ...item, count: 1 }];\r\n        }\r\n        \r\n        saveCartToLocalStorage(updatedItems);\r\n        return updatedItems;\r\n      });\r\n    }\r\n  };\r\n\r\n  const removeFromCart = async (productId: string, variant: string) => {\r\n    // If authenticated and productId is valid, remove from backend first\r\n    if (isAuthenticated && isValidObjectId(productId)) {\r\n      try {\r\n        setLoading(true);\r\n        // Remove from backend first\r\n        await removeFromCartApi(productId, variant || undefined);\r\n        \r\n        // After successful backend removal, reload cart from backend to ensure sync\r\n        const response = await getCart();\r\n        if (response.success && response.data?.items) {\r\n          const backendCartItems: CartItem[] = response.data.items\r\n            .filter((item: any) => item.product)\r\n            .map((item: any) => {\r\n              const product = item.product;\r\n              const productId = product?._id?.toString() || product?.toString() || '';\r\n              \r\n              let variantName = '';\r\n              if (item.variantId && product?.variants) {\r\n                const variant = product.variants.find((v: any) => \r\n                  v._id?.toString() === item.variantId || v._id === item.variantId\r\n                );\r\n                variantName = variant?.name || '';\r\n              }\r\n\r\n              return {\r\n                productId,\r\n                name: product?.name || '',\r\n                brand: product?.brand?.name || '',\r\n                image: product?.images?.[0] || '',\r\n                variant: variantName,\r\n                quantity: item.quantity?.toString() || '1',\r\n                price: Number(item.unitPrice) || 0,\r\n                originalPrice: Number(item.unitPrice) || 0,\r\n                count: item.quantity || 1,\r\n              };\r\n            })\r\n            .filter((item: CartItem) => item.productId);\r\n\r\n          setItems(backendCartItems);\r\n          saveCartToLocalStorage(backendCartItems);\r\n        } else {\r\n          // Backend cart is empty\r\n          setItems([]);\r\n          saveCartToLocalStorage([]);\r\n        }\r\n        setLoading(false);\r\n      } catch (error: any) {\r\n        console.error('Error removing from cart:', error);\r\n        setLoading(false);\r\n        const errorMessage = error?.response?.data?.message || error?.message || 'Failed to remove item from cart';\r\n        alert(errorMessage);\r\n        throw error;\r\n      }\r\n    } else {\r\n      // For guest users or mock data, update local state\r\n      setItems((prevItems) => {\r\n        const updatedItems = prevItems.filter(\r\n          (i) => !(i.productId === productId && i.variant === variant)\r\n        );\r\n        saveCartToLocalStorage(updatedItems);\r\n        return updatedItems;\r\n      });\r\n    }\r\n  };\r\n\r\n  const updateQuantity = async (productId: string, variant: string, count: number) => {\r\n    if (count <= 0) {\r\n      await removeFromCart(productId, variant);\r\n      return;\r\n    }\r\n\r\n    // If authenticated and productId is valid, update backend first\r\n    if (isAuthenticated && isValidObjectId(productId)) {\r\n      try {\r\n        setLoading(true);\r\n        // Update backend first\r\n        await updateCartItem(productId, count, variant || undefined);\r\n        \r\n        // After successful backend update, reload cart from backend to ensure sync\r\n        const response = await getCart();\r\n        if (response.success && response.data?.items) {\r\n          const backendCartItems: CartItem[] = response.data.items\r\n            .filter((item: any) => item.product)\r\n            .map((item: any) => {\r\n              const product = item.product;\r\n              const productId = product?._id?.toString() || product?.toString() || '';\r\n              \r\n              let variantName = '';\r\n              if (item.variantId && product?.variants) {\r\n                const variant = product.variants.find((v: any) => \r\n                  v._id?.toString() === item.variantId || v._id === item.variantId\r\n                );\r\n                variantName = variant?.name || '';\r\n              }\r\n\r\n              return {\r\n                productId,\r\n                name: product?.name || '',\r\n                brand: product?.brand?.name || '',\r\n                image: product?.images?.[0] || '',\r\n                variant: variantName,\r\n                quantity: item.quantity?.toString() || '1',\r\n                price: Number(item.unitPrice) || 0,\r\n                originalPrice: Number(item.unitPrice) || 0,\r\n                count: item.quantity || 1,\r\n              };\r\n            })\r\n            .filter((item: CartItem) => item.productId);\r\n\r\n          setItems(backendCartItems);\r\n          saveCartToLocalStorage(backendCartItems);\r\n        }\r\n        setLoading(false);\r\n      } catch (error: any) {\r\n        console.error('Error updating cart:', error);\r\n        setLoading(false);\r\n        const errorMessage = error?.response?.data?.message || error?.message || 'Failed to update cart';\r\n        alert(errorMessage);\r\n        throw error;\r\n      }\r\n    } else {\r\n      // For guest users or mock data, update local state\r\n      setItems((prevItems) => {\r\n        const updatedItems = prevItems.map((i) =>\r\n          i.productId === productId && i.variant === variant\r\n            ? { ...i, count }\r\n            : i\r\n        );\r\n        saveCartToLocalStorage(updatedItems);\r\n        return updatedItems;\r\n      });\r\n    }\r\n  };\r\n\r\n  const clearCart = async () => {\r\n    // Update local state immediately\r\n    setItems([]);\r\n    saveCartToLocalStorage([]);\r\n\r\n    // Sync with backend if authenticated\r\n    if (isAuthenticated) {\r\n      try {\r\n        await clearCartApi();\r\n      } catch (error) {\r\n        console.error('Error clearing cart:', error);\r\n      }\r\n    }\r\n  };\r\n\r\n  const getTotalItems = () => {\r\n    return items.reduce((total, item) => total + item.count, 0);\r\n  };\r\n\r\n  const getTotalPrice = () => {\r\n    return items.reduce((total, item) => total + item.price * item.count, 0);\r\n  };\r\n\r\n  return (\r\n    <CartContext.Provider\r\n      value={{\r\n        items,\r\n        loading,\r\n        addToCart,\r\n        removeFromCart,\r\n        updateQuantity,\r\n        clearCart,\r\n        getTotalItems,\r\n        getTotalPrice,\r\n        syncCart,\r\n      }}\r\n    >\r\n      {children}\r\n    </CartContext.Provider>\r\n  );\r\n}\r\n\r\nexport function useCart() {\r\n  const context = useContext(CartContext);\r\n  if (context === undefined) {\r\n    throw new Error('useCart must be used within a CartProvider');\r\n  }\r\n  return context;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}}]
}